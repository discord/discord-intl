use quote::{format_ident, quote, ToTokens};
use serde::Deserialize;
use std::collections::BTreeMap;
use xtask::util;
use xtask::util::Codegen;

#[derive(Deserialize)]
struct ExampleDef {
    #[serde(rename = "example")]
    number: usize,
    section: String,
    #[serde(rename = "markdown")]
    input: String,
    #[serde(rename = "html")]
    output: String,
    #[serde(rename = "shouldSkip")]
    should_skip: Option<bool>,
}

impl ExampleDef {
    pub fn test_name(&self) -> String {
        format!("{}", self.number)
    }

    pub fn should_skip(&self) -> bool {
        self.should_skip.unwrap_or(false)
    }

    pub fn test_def(&self) -> impl ToTokens {
        let test_name = format_ident!("example_{}", self.test_name());
        let input = &self.input;
        let output = &self.output;
        let test_attr = if self.should_skip() {
            quote! { #[ignore] #[test] }
        } else {
            quote! { #[test] }
        };
        quote! {
            #test_attr
            fn #test_name() {
                let input = #input;
                let expected = #output;

                let parsed = harness::parse(input);

                assert_eq!(expected, parsed);
            }
        }
    }
}

fn check_should_skip_test_case(section: &str, content: &str, output: &str) -> bool {
    // Skip anything with lists.
    if output.contains("<li>") {
        return true;
    }

    // Skipping things with link references.
    for line in content.lines() {
        if line.contains("]:") {
            return true;
        }
    }

    // Skipping anything with inline html, but preserve autolink tests.
    if content.contains("<") {
        return (section != "autolinks"
            && section != "code_spans"
            && section != "emphasis_and_strong_emphasis")
            || content.contains("<a")
            || content.contains("<img");
    }

    // Skipping hard breaks from br tags and blockquotes
    if output.contains("<blockquote>") {
        return true;
    }

    let allowed = vec![
        "autolinks",
        "backslash_escapes",
        "code_spans",
        "inlines",
        "links",
        "images",
        "soft_line_breaks",
        "hard_line_breaks",
        "paragraphs",
        "fenced_code_blocks",
        "indented_code_blocks",
        "atx_headings",
        "setext_headings",
        "thematic_breaks",
        "tabs",
        "textual_content",
        "emphasis_and_strong_emphasis",
        "entity_and_numeric_character_references",
        "blank_lines",
    ];

    !allowed.contains(&section)
}

fn sluggify(line: &str) -> String {
    let heading_chars = line.chars().skip_while(|c| *c == '#');

    let mut slug = String::with_capacity(line.len());

    for c in heading_chars {
        // Skip leading whitespace
        if slug.is_empty() && c.is_whitespace() {
            continue;
        }

        // Skip punctuation
        if c.is_ascii_punctuation() {
            continue;
        }

        // Convert whitespace to underscores
        if c.is_whitespace() {
            slug.push('_');
            continue;
        }

        // Otherwise, add the character in lowercase
        slug.push(c.to_ascii_lowercase());
    }

    slug
}

fn get_cases_by_section(cases: Vec<ExampleDef>) -> BTreeMap<String, Vec<ExampleDef>> {
    let mut cases_by_section: BTreeMap<String, Vec<ExampleDef>> = BTreeMap::new();
    for example in cases.into_iter() {
        cases_by_section
            .entry(example.section.clone())
            .or_insert_with(Vec::new)
            .push(example);
    }
    cases_by_section
}

fn get_examples() -> Vec<ExampleDef> {
    let mut cases: Vec<ExampleDef> = serde_json::from_str(include_str!("./spec_tests.json"))
        .expect("Failed to parse spec tests");

    for example in cases.iter_mut() {
        example.section = sluggify(&example.section);
        example.input = example.input.trim_end_matches('\n').into();
        example.output = example.output.trim_end_matches('\n').into();
        example.should_skip = Some(check_should_skip_test_case(
            &example.section,
            &example.input,
            &example.output,
        ));
    }
    cases
}

fn get_module_prelude() -> impl ToTokens {
    quote! {
        //! This module is autogenerated with `cargo xtask gen-spec-tests`. The
        //! source for this script lives at `xtask/src/bin/gen-spec-tests.rs`.

        use super::harness;
    }
}

fn try_main() -> anyhow::Result<()> {
    let mut codegen =
        Codegen::new(util::repo_root().join("crates/intl_markdown/tests/spec/commonmark"));
    let examples = get_examples();
    let cases_by_section = get_cases_by_section(examples);

    let sections = cases_by_section
        .keys()
        .map(|section| format_ident!("{}", section))
        .collect::<Vec<_>>();
    let test_harness = quote! {
        #[cfg(test)]
        mod harness {
            use intl_markdown::{ICUMarkdownParser, SourceText, compiler};

            pub fn parse(input: &str) -> String {
                let mut parser = ICUMarkdownParser::new(SourceText::from(input), true);
                #[cfg(feature = "debug-tracing")]
                println!("Blocks: {:?}\n", parser.lexer_block_bounds());

                parser.parse();
                #[cfg(feature = "debug-tracing")]
                println!("Tokens:\n-------\n{:#?}\n", parser.debug_token_list());

                let result = parser.finish();
                println!("Tree:\n-------\n{:#?}\n", result.tree);

                let document = result.to_document();
                println!("CST:\n----\n{:#?}\n", document);

                let compiled = compiler::compile_document(&document);
                println!("Compiled:\n---------\n{:#?}\n", compiled);

                let output = format::to_html(&compiled);
                println!("Input:\n------\n{}\n", input);
                println!("HTML Format:\n------------\n{}\n{:?}", output, output);

                output
            }
        }
    };
    codegen.write_file(
        "mod.rs",
        quote! {
            #test_harness

            #(mod #sections;)*
        }
        .to_string(),
    )?;

    let module_prelude = get_module_prelude();
    for (section, cases) in cases_by_section {
        let mut file_content = quote!();
        module_prelude.to_tokens(&mut file_content);

        for case in cases {
            case.test_def().to_tokens(&mut file_content);
        }
        codegen.write_file(format!("{}.rs", section), file_content.to_string())?;
    }

    codegen.finish()
}

fn main() {
    try_main().unwrap_or_else(|e| {
        eprintln!("{}", e);
        std::process::exit(1);
    });
}
