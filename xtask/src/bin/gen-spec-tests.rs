use quote::{format_ident, quote, ToTokens};
use serde::Deserialize;
use std::collections::BTreeMap;
use xtask::util;

#[derive(Deserialize)]
struct ExampleDef {
    #[serde(rename = "example")]
    number: usize,
    section: String,
    #[serde(rename = "markdown")]
    input: String,
    #[serde(rename = "html")]
    output: String,
    #[serde(rename = "shouldSkip")]
    should_skip: Option<bool>,
}

impl ExampleDef {
    pub fn test_name(&self) -> String {
        format!("{}", self.number)
    }

    pub fn should_skip(&self) -> bool {
        self.should_skip.unwrap_or(false)
    }

    pub fn test_def(&self) -> impl ToTokens {
        let test_name = format_ident!("example_{}", self.test_name());
        let input = self.input.escape_default().to_string();
        let output = self.output.escape_default().to_string();
        let test_attr = if self.should_skip() {
            quote! { #[ignore] #[test] }
        } else {
            quote! { #[test] }
        };
        quote! {
            #test_attr
            fn #test_name() {
                let input = #input;
                let expected = #output;

                let parsed = harness::parse(input);

                assert_eq!(expected, parsed);
            }
        }
    }
}

fn check_should_skip_test_case(section: &str, content: &str, output: &str) -> bool {
    // Skip anything with lists.
    if output.contains("<li>") {
        return true;
    }

    // Skipping things with link references.
    for line in content.lines() {
        if line.contains("]:") {
            return true;
        }
    }

    // Skipping anything with inline html, but preserve autolink tests.
    if content.contains("<") {
        return (section != "autolinks"
            && section != "code_spans"
            && section != "emphasis_and_strong_emphasis")
            || content.contains("<a")
            || content.contains("<img");
    }

    // Skipping hard breaks from br tags and blockquotes
    if output.contains("<blockquote>") {
        return true;
    }

    let allowed = vec![
        "autolinks",
        "backslash_escapes",
        "code_spans",
        "inlines",
        "links",
        "images",
        "soft_line_breaks",
        "hard_line_breaks",
        "paragraphs",
        "fenced_code_blocks",
        "indented_code_blocks",
        "atx_headings",
        "setext_headings",
        "thematic_breaks",
        "tabs",
        "textual_content",
        "emphasis_and_strong_emphasis",
        "entity_and_numeric_character_references",
        "blank_lines",
    ];

    !allowed.contains(&section)
}

fn sluggify(line: &str) -> String {
    let heading_chars = line.chars().skip_while(|c| *c == '#');

    let mut slug = String::with_capacity(line.len());

    for c in heading_chars {
        // Skip leading whitespace
        if slug.is_empty() && c.is_whitespace() {
            continue;
        }

        // Skip punctuation
        if c.is_ascii_punctuation() {
            continue;
        }

        // Convert whitespace to underscores
        if c.is_whitespace() {
            slug.push('_');
            continue;
        }

        // Otherwise, add the character in lowercase
        slug.push(c.to_ascii_lowercase());
    }

    slug
}

fn get_cases_by_section(cases: Vec<ExampleDef>) -> BTreeMap<String, Vec<ExampleDef>> {
    let mut cases_by_section: BTreeMap<String, Vec<ExampleDef>> = BTreeMap::new();
    for example in cases.into_iter() {
        cases_by_section
            .entry(example.section.clone())
            .or_insert_with(Vec::new)
            .push(example);
    }
    cases_by_section
}

fn get_examples() -> Vec<ExampleDef> {
    let mut cases: Vec<ExampleDef> = serde_json::from_str(include_str!("./spec_tests.json"))
        .expect("Failed to parse spec tests");

    for example in cases.iter_mut() {
        example.section = sluggify(&example.section);
        example.input = example.input.trim_end_matches('\n').into();
        example.output = example.output.trim_end_matches('\n').into();
        example.should_skip = Some(check_should_skip_test_case(
            &example.section,
            &example.input,
            &example.output,
        ));
    }
    cases
}

fn try_main() -> anyhow::Result<()> {
    let module_prelude = quote! {
        //! This module is autogenerated with `cargo xtask gen-spec-tests`. The
        //! source for this script lives at `xtask/src/bin/gen-spec-tests.rs`.

        //#region Harness
        mod harness {
            use intl_markdown::{ICUMarkdownParser, SourceText, commonmark_html};

            pub fn parse(input: &str) -> String {
                let mut parser = ICUMarkdownParser::new(SourceText::from(input), true);
                parser.parse();
                let ast = parser.finish().to_document();
                let mut buffer = String::new();
                commonmark_html::format_document(&mut buffer, &ast).expect("Failed to format the parsed input");
                buffer
            }
        }

        //#endregion

        // Spec Test Cases
    };

    let examples = get_examples();
    let cases_by_section = get_cases_by_section(examples);

    let repo_root = util::repo_root();
    let tests_dir = repo_root.join("crates/intl_markdown/tests/commonmark");
    std::fs::create_dir_all(&tests_dir)?;

    let commonmark_module = tests_dir.join("mod.rs");
    let sections = cases_by_section
        .keys()
        .map(|section| format_ident!("{}", section))
        .collect::<Vec<_>>();
    std::fs::write(
        &commonmark_module,
        quote! {
            #(mod #sections;)*
        }
        .to_string(),
    )?;

    let mut files_to_format = vec![commonmark_module];

    for (section, cases) in cases_by_section {
        let output_file = tests_dir.join(format!("{}.rs", section));
        let mut file_content = module_prelude.clone();

        for case in cases {
            case.test_def().to_tokens(&mut file_content);
        }
        std::fs::write(&output_file, file_content.to_string())?;
        files_to_format.push(output_file);
    }

    util::format_files(files_to_format.iter())?;

    Ok(())
}

fn main() {
    try_main().unwrap_or_else(|e| {
        eprintln!("{}", e);
        std::process::exit(1);
    });
}
