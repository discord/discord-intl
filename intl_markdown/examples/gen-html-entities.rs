use std::{collections::HashMap, fmt::Write, path::PathBuf, str::FromStr};

use serde::Deserialize;

#[derive(Deserialize, PartialEq, PartialOrd, Eq, Ord)]
struct HTMLEntity {
    characters: String,
    #[allow(dead_code)]
    codepoints: Vec<usize>,
}

fn main() {
    let entities: HashMap<String, HTMLEntity> =
        serde_json::from_str(include_str!("./html-entities.json"))
            .expect("Failed to parse html entities");

    // Output the test contents into test case folders to read as individual
    // tests afterward.
    let html_file = PathBuf::from_str("./src/html_entities.rs").unwrap();
    let mut output_buffer = String::new();

    output_buffer.push_str(&format!(
        "//! This module is autogenerated with `cargo run --bin gen-html-entities`. The
//! source for this script lives at `examples/gen-html-entities.rs`.

const HTML_ENTITIES: [(&[u8], &str); {}] = [
",
        entities.len()
    ));

    let mut sorted_entities = entities.into_iter().collect::<Vec<(String, HTMLEntity)>>();
    sorted_entities.sort();

    for (name, entity) in sorted_entities {
        output_buffer
            .write_str(&format!(
                "    (b\"{}\", \"{}\"),\n",
                name,
                entity.characters.escape_unicode(),
            ))
            .expect(&format!("failed to write entity {}", name));
    }

    output_buffer
        .write_str(
            "];

pub fn is_html_entity(text: &[u8]) -> bool {
    HTML_ENTITIES
        .binary_search_by_key(&text, |&(key, _value)| key)
        .is_ok()
}

pub fn get_html_entity(text: &[u8]) -> Option<&'static str> {
    HTML_ENTITIES
        .binary_search_by_key(&text, |&(key, _value)| key)
        .ok()
        .map(|i| HTML_ENTITIES[i].1)
}
",
        )
        .expect("failed to write end of html entities");

    std::fs::write(html_file, output_buffer).expect("Failed to write the specs file");
}
