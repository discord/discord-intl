//! ASTs are constructed from a pre-built CST (the result of using `tree_builder`, and the result
//! of calling `parser_events_to_ast()`. The CST is useful for reconstructing the exact text as it
//! was written, such as when writing a source formatter or when constructing lints. But it is not
//! useful for actually _rendering_ Markdown into a result like HTML or a semantic JSON
//! representation, since the rules of Markdown involve processing whitespace and line breaks
//! in various ways that _don't_ appear in the final result.
//!
//! The semantic AST generated by this module is responsible for implementing those processes and
//! providing views to the results with typed accessors, such as `Link::title` to get the rendered
//! title of a link, or `Paragraph::content` to get the rendered, trimmed content of a paragraph.
//!
//! The structure of this AST largely mirrors that of the CST, but with many of the interior nodes
//! removed and replaced with simple String values (such as LinkTitle, LinkResource, etc.), and
//! other nodes merged into single representations, like AtxHeading and SetextHeading becoming a
//! single Heading struct with a `kind` property indicating which it came from.

pub mod format;
pub mod process;
pub mod util;

#[derive(Clone, Debug)]
pub struct Document {
    blocks: Vec<BlockNode>,
}
impl Document {
    pub fn blocks(&self) -> &Vec<BlockNode> {
        &self.blocks
    }
}

#[derive(Clone, Debug)]
pub enum BlockNode {
    Paragraph(Paragraph),
    Heading(Heading),
    CodeBlock(CodeBlock),
    ThematicBreak,
    /// Inline content directly added to a Document, generally only in the case of using inline
    /// mode, where the content is intentionally _not_ placed inside a paragraph.
    InlineContent(Vec<InlineContent>),
}

#[derive(Clone, Debug)]
#[repr(transparent)]
pub struct Paragraph(Vec<InlineContent>);
impl Paragraph {
    pub fn content(&self) -> &Vec<InlineContent> {
        &self.0
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum HeadingKind {
    Atx,
    Setext,
}

#[derive(Clone, Debug)]
pub struct Heading {
    kind: HeadingKind,
    level: u8,
    content: Vec<InlineContent>,
}
impl Heading {
    pub fn kind(&self) -> &HeadingKind {
        &self.kind
    }

    pub fn level(&self) -> u8 {
        self.level
    }

    pub fn content(&self) -> &Vec<InlineContent> {
        &self.content
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum CodeBlockKind {
    Indented,
    Fenced,
}

#[derive(Clone, Debug)]
pub struct CodeBlock {
    kind: CodeBlockKind,
    language: Option<String>,
    info_string: Option<String>,
    content: String,
}
impl CodeBlock {
    pub fn kind(&self) -> &CodeBlockKind {
        &self.kind
    }
    pub fn language(&self) -> &Option<String> {
        &self.language
    }
    pub fn info_string(&self) -> &Option<String> {
        &self.info_string
    }
    pub fn content(&self) -> &String {
        &self.content
    }
}

#[derive(Clone, Debug, Eq, PartialEq)]
pub enum InlineContent {
    Text(String),
    Emphasis(Emphasis),
    Strong(Strong),
    Link(Link),
    CodeSpan(CodeSpan),
    HardLineBreak,
    Hook(Hook),
    Strikethrough(Strikethrough),
    Icu(Icu),
    /// IcuPound is a special case for the `#` token inside an ICU plural value, such as
    /// `{count, plural, one {# item} other {# items}}`. It represents a placeholder for the same
    /// variable as the outer context (`count` in this case), and gets treated exactly as if
    /// written as `{count, number}`.
    ///
    /// This is _not_ kept under the `Icu` variant because it's not written with the same curly
    /// brace syntax on itself. However, it is _only_ valid inside of plural values. A hash used
    /// outside of a plural value will just be treated as a literal hash character (or interpreted
    /// as Markdown syntax if appropriate).
    IcuPound,
}

#[derive(Clone, Debug, Eq, PartialEq)]
#[repr(transparent)]
pub struct Emphasis(Vec<InlineContent>);
impl Emphasis {
    pub fn content(&self) -> &Vec<InlineContent> {
        &self.0
    }
}

#[derive(Clone, Debug, Eq, PartialEq)]
#[repr(transparent)]
pub struct Strong(Vec<InlineContent>);
impl Strong {
    pub fn content(&self) -> &Vec<InlineContent> {
        &self.0
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum LinkKind {
    Link,
    Image,
    Autolink,
    Email,
}

#[derive(Clone, Debug, Eq, PartialEq)]
pub enum TextOrPlaceholder {
    Text(String),
    Placeholder(Icu),
}

impl TextOrPlaceholder {
    pub fn is_text(&self) -> bool {
        matches!(self, TextOrPlaceholder::Text(_))
    }
    pub fn is_placeholder(&self) -> bool {
        matches!(self, TextOrPlaceholder::Placeholder(_))
    }
}

#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Link {
    kind: LinkKind,
    label: Vec<InlineContent>,
    destination: TextOrPlaceholder,
    title: Option<String>,
}

impl Link {
    pub fn kind(&self) -> LinkKind {
        self.kind
    }
    pub fn label(&self) -> &Vec<InlineContent> {
        &self.label
    }
    pub fn destination(&self) -> &TextOrPlaceholder {
        &self.destination
    }
    pub fn title(&self) -> &Option<String> {
        &self.title
    }
}

#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Hook {
    content: Vec<InlineContent>,
    name: String,
}

impl Hook {
    pub fn name(&self) -> &String {
        &self.name
    }
    pub fn content(&self) -> &Vec<InlineContent> {
        &self.content
    }
}

#[derive(Clone, Debug, Eq, PartialEq)]
#[repr(transparent)]
pub struct Strikethrough(Vec<InlineContent>);
impl Strikethrough {
    pub fn content(&self) -> &Vec<InlineContent> {
        &self.0
    }
}

#[derive(Clone, Debug, Eq, PartialEq)]
#[repr(transparent)]
pub struct CodeSpan(String);
impl CodeSpan {
    pub fn content(&self) -> &String {
        &self.0
    }
}

#[derive(Clone, Debug, Eq, PartialEq)]
pub enum Icu {
    IcuVariable(IcuVariable),
    IcuPlural(IcuPlural),
    IcuDate(IcuDate),
    IcuTime(IcuTime),
    IcuNumber(IcuNumber),
}

impl Icu {
    #[inline(always)]
    pub fn is_unsafe(&self) -> bool {
        match self {
            Icu::IcuVariable(variable) => variable.is_unsafe(),
            Icu::IcuPlural(plural) => plural.is_unsafe(),
            Icu::IcuDate(date) => date.is_unsafe(),
            Icu::IcuTime(time) => time.is_unsafe(),
            Icu::IcuNumber(number) => number.is_unsafe(),
        }
    }
}

#[derive(Clone, Debug, Eq, PartialEq)]
pub struct IcuVariable {
    name: String,
    is_unsafe: bool,
}
impl IcuVariable {
    pub fn name(&self) -> &String {
        &self.name
    }

    pub fn is_unsafe(&self) -> bool {
        self.is_unsafe
    }
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
pub enum IcuPluralKind {
    Plural,
    Select,
    SelectOrdinal,
}

#[derive(Clone, Debug, Eq, PartialEq)]
pub struct IcuPlural {
    variable: IcuVariable,
    kind: IcuPluralKind,
    arms: Vec<IcuPluralArm>,
    is_unsafe: bool,
}
impl IcuPlural {
    pub fn variable(&self) -> &IcuVariable {
        &self.variable
    }

    pub fn name(&self) -> &String {
        self.variable.name()
    }

    pub fn kind(&self) -> &IcuPluralKind {
        &self.kind
    }

    pub fn arms(&self) -> &Vec<IcuPluralArm> {
        &self.arms
    }

    pub fn is_unsafe(&self) -> bool {
        self.is_unsafe
    }
}

#[derive(Clone, Debug, Eq, PartialEq)]
pub struct IcuPluralArm {
    selector: String,
    content: Vec<InlineContent>,
}
impl IcuPluralArm {
    pub fn selector(&self) -> &String {
        &self.selector
    }

    pub fn content(&self) -> &Vec<InlineContent> {
        &self.content
    }
}

#[derive(Clone, Debug, Eq, PartialEq)]
pub struct IcuDate {
    variable: IcuVariable,
    style: Option<IcuDateTimeStyle>,
    is_unsafe: bool,
}
impl IcuDate {
    pub fn variable(&self) -> &IcuVariable {
        &self.variable
    }
    pub fn name(&self) -> &String {
        self.variable.name()
    }
    pub fn style(&self) -> &Option<IcuDateTimeStyle> {
        &self.style
    }
    pub fn is_unsafe(&self) -> bool {
        self.is_unsafe
    }
}

#[derive(Clone, Debug, Eq, PartialEq)]
pub struct IcuTime {
    variable: IcuVariable,
    style: Option<IcuDateTimeStyle>,
    is_unsafe: bool,
}
impl IcuTime {
    pub fn variable(&self) -> &IcuVariable {
        &self.variable
    }
    pub fn name(&self) -> &String {
        self.variable.name()
    }
    pub fn style(&self) -> &Option<IcuDateTimeStyle> {
        &self.style
    }
    pub fn is_unsafe(&self) -> bool {
        self.is_unsafe
    }
}

#[derive(Clone, Debug, Eq, PartialEq)]
pub struct IcuDateTimeStyle {
    text: String,
}
impl IcuDateTimeStyle {
    pub fn text(&self) -> &String {
        &self.text
    }
}

#[derive(Clone, Debug, Eq, PartialEq)]
pub struct IcuNumber {
    variable: IcuVariable,
    style: Option<IcuNumberStyle>,
    is_unsafe: bool,
}
impl IcuNumber {
    pub fn variable(&self) -> &IcuVariable {
        &self.variable
    }
    pub fn name(&self) -> &String {
        self.variable.name()
    }
    pub fn style(&self) -> &Option<IcuNumberStyle> {
        &self.style
    }
    pub fn is_unsafe(&self) -> bool {
        self.is_unsafe
    }
}

#[derive(Clone, Debug, Eq, PartialEq)]
pub struct IcuNumberStyle {
    text: String,
}
impl IcuNumberStyle {
    pub fn text(&self) -> &String {
        &self.text
    }
}
