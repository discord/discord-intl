use intl_database_core::{FilePosition, KeySymbol};
use sourcemap::SourceMapBuilder;
use std::collections::{BTreeMap, BTreeSet};
use std::fmt::Write;

pub(crate) type AlphabeticSymbolSet = BTreeSet<KeySymbol>;
pub(crate) type AlphabeticSymbolMap<V> = BTreeMap<KeySymbol, V>;

/// Struct for writing code to an output buffer with some basic utilities to help with writing
/// documentation comments. This is not a _formatter_, as in it does not process text to decide
/// how it should look. Callers are responsible for laying out text in terms of lines and columns.
/// This writer will handle adding indentation, tracking the current position.
pub(crate) struct TypeDocWriter {
    output: String,
    pub line: usize,
    pub col: usize,
    line_prefix: String,
    prefix_stack: Vec<usize>,
    pub source_map: SourceMapBuilder,
}

impl TypeDocWriter {
    pub fn new() -> Self {
        Self {
            output: String::new(),
            // This is primarily for sourcemaps, which _seem_ to use 1-based indexing for the
            // _generated_ code, but 0-based indexing for the original source.
            line: 1,
            // Columns are always 0-based, though.
            col: 0,
            line_prefix: String::with_capacity(8),
            prefix_stack: Vec::with_capacity(8),
            source_map: SourceMapBuilder::new(None),
        }
    }

    pub fn take_buffer(&mut self) -> String {
        std::mem::take(&mut self.output)
    }

    pub fn add_source_map_entry(&mut self, definition_position: FilePosition) {
        self.source_map.add_raw(
            self.line as u32,
            self.col as u32,
            // I couldn't possibly tell you whether 0- or 1-based indexing is correct.
            // The spec doesn't say which.
            definition_position.line - 1,
            definition_position.col,
            Some(0),
            None,
            false,
        );
    }

    pub fn write_prelude(&mut self) -> WriteResult {
        write!(self,
            "/* THIS FILE IS AUTOGENERATED. DO NOT EDIT MANUALLY. */
/* eslint-disable */
/* prettier-ignore */

import {{MessageLoader, TypedIntlMessageGetter, HandlerFunction, HookFunction, LinkFunction}} from '{}';

export declare const messagesLoader: MessageLoader;

declare const messages: {{",
            intl_message_utils::RUNTIME_PACKAGE_NAME
        )
    }
}

// Internal API
impl TypeDocWriter {
    pub fn indent(&mut self) {
        self.push_prefix("  ")
    }

    pub fn dedent(&mut self) {
        debug_assert!(
            self.line_prefix.ends_with("  "),
            "end of the current prefix is not an indentation"
        );
        self.pop_prefix();
    }

    pub fn push_prefix(&mut self, content: &str) {
        debug_assert!(
            !content.contains('\n'),
            "line prefixes should not contain newlines. Adding '{content}' to '{}'",
            self.line_prefix
        );
        self.prefix_stack.push(self.line_prefix.len());
        self.line_prefix += content;
    }

    pub fn pop_prefix(&mut self) {
        let Some(last_index) = self.prefix_stack.pop() else {
            return;
        };

        self.line_prefix.truncate(last_index);
    }
}

// Writing API
impl Write for TypeDocWriter {
    fn write_str(&mut self, buf: &str) -> std::fmt::Result {
        let mut lines = buf.lines().peekable();
        let has_final_line = buf.ends_with('\n');
        loop {
            let Some(line) = lines.next() else {
                break;
            };
            // First, write the line as a continuation of whatever was there previously.
            self.output.write_str(line)?;

            // If there's another line after this, regardless of whether it has content, write a
            // newline and the current line prefix through the buffer.
            let has_next_line = lines.peek().is_some() || has_final_line;
            if has_next_line {
                self.output.write_str("\n")?;
                self.line += 1;
                self.output.write_str(&self.line_prefix)?;
                self.col = self.line_prefix.len();
            }
        }

        Ok(())
    }
}

pub(crate) type WriteResult = std::fmt::Result;

pub(crate) trait TypeDocFormat {
    fn fmt(&self, w: &mut TypeDocWriter) -> WriteResult;
}

macro_rules! write_doc {
    ($dst:expr, [$($arg:expr),+ $(,)?]) => {{
        $(
            let _ = TypeDocFormat::fmt($arg, &mut $dst)?;
        )*
        Ok(())
    }}
}

pub(crate) use write_doc;

impl TypeDocFormat for str {
    #[inline(always)]
    fn fmt(&self, w: &mut TypeDocWriter) -> WriteResult {
        w.write_str(&self)?;
        Ok(())
    }
}
impl TypeDocFormat for &str {
    #[inline(always)]
    fn fmt(&self, w: &mut TypeDocWriter) -> WriteResult {
        w.write_str(self.as_ref())?;
        Ok(())
    }
}
impl TypeDocFormat for KeySymbol {
    #[inline(always)]
    fn fmt(&self, w: &mut TypeDocWriter) -> WriteResult {
        w.write_str(self.as_ref())?;
        Ok(())
    }
}
impl TypeDocFormat for &KeySymbol {
    #[inline(always)]
    fn fmt(&self, w: &mut TypeDocWriter) -> WriteResult {
        w.write_str(self.as_ref())?;
        Ok(())
    }
}
impl TypeDocFormat for [&str; 3] {
    #[inline(always)]
    fn fmt(&self, w: &mut TypeDocWriter) -> WriteResult {
        for item in self {
            w.write_str(item)?;
        }
        Ok(())
    }
}

impl<T: TypeDocFormat> TypeDocFormat for Option<T> {
    #[inline(always)]
    fn fmt(&self, mut w: &mut TypeDocWriter) -> WriteResult {
        match self {
            Some(content) => {
                write_doc!(w, [content])?;
                Ok(())
            }
            _ => Ok(()),
        }
    }
}

pub(super) fn source_map_entry(position: FilePosition) -> SourceMapWriterEntry {
    SourceMapWriterEntry {
        original_position: position,
    }
}

/// Struct indicating that a source map entry should be added from the current position in the
/// writer's output to the given `original_position`.
///
/// This does not actually write anything to the output.
pub(super) struct SourceMapWriterEntry {
    original_position: FilePosition,
}

impl TypeDocFormat for SourceMapWriterEntry {
    fn fmt(&self, w: &mut TypeDocWriter) -> WriteResult {
        w.add_source_map_entry(self.original_position);
        Ok(())
    }
}
