use std::{collections::BTreeMap, path::PathBuf, str::FromStr};

use serde::Deserialize;

#[derive(Deserialize)]
struct ExampleDef {
    #[serde(rename = "example")]
    number: usize,
    section: String,
    #[serde(rename = "markdown")]
    input: String,
    #[serde(rename = "html")]
    output: String,
    should_skip: Option<bool>,
}

fn check_should_skip_test_case(section: &str, content: &str, output: &str) -> bool {
    // Skip anything with lists.
    if output.contains("<li>") {
        return true;
    }

    // Skipping things with link references.
    for line in content.lines() {
        if line.contains("]:") {
            return true;
        }
    }

    // Skipping anything with inline html, but preserve autolink tests.
    if content.contains("<") {
        return (section != "autolinks"
            && section != "code_spans"
            && section != "emphasis_and_strong_emphasis")
            || content.contains("<a")
            || content.contains("<img");
    }

    // Skipping image tags, and links with titles
    // if content.contains("![") {
    //     return true;
    // }

    // Skipping hard breaks from br tags and blockquotes
    if output.contains("<blockquote>") {
        return true;
    }

    let allowed = vec![
        "autolinks",
        "backslash_escapes",
        "code_spans",
        "inlines",
        "links",
        "images",
        "soft_line_breaks",
        "hard_line_breaks",
        "paragraphs",
        "fenced_code_blocks",
        "indented_code_blocks",
        "atx_headings",
        "setext_headings",
        "thematic_breaks",
        "tabs",
        "textual_content",
        "emphasis_and_strong_emphasis",
        "entity_and_numeric_character_references",
        "blank_lines",
    ];

    return !allowed.contains(&section);
}

fn sluggify(line: &str) -> String {
    let heading_chars = line.chars().skip_while(|c| *c == '#');

    let mut slug = String::with_capacity(line.len());

    for c in heading_chars {
        // Skip leading whitespace
        if slug.is_empty() && c.is_whitespace() {
            continue;
        }

        // Skip punctuation
        if c.is_ascii_punctuation() {
            continue;
        }

        // Convert whitespace to underscores
        if c.is_whitespace() {
            slug.push('_');
            continue;
        }

        // Otherwise, add the character in lowercase
        slug.push(c.to_ascii_lowercase());
    }

    slug
}

fn main() {
    let mut cases: Vec<ExampleDef> = serde_json::from_str(include_str!("./spec_tests.json"))
        .expect("Failed to parse spec tests");

    for ExampleDef {
        number: _,
        section,
        input,
        output,
        should_skip,
    } in cases.iter_mut()
    {
        *section = sluggify(section);
        *input = input.trim_end_matches('\n').into();
        *output = output.trim_end_matches('\n').into();
        *should_skip = Some(check_should_skip_test_case(&section, &input, &output));
    }

    // Output the test contents into test case folders to read as individual
    // tests afterward.
    let specs_file = PathBuf::from_str("./tests/mod.rs").unwrap();
    let mut output_buffer = String::new();

    output_buffer.push_str(
        "//! This module is autogenerated with `cargo run --bin gen-spec-tests`. The
//! source for this script lives at `examples/gen-spec-tests.rs`.

use test_case::test_case;

mod harness;
use harness::run_spec_test;

",
    );

    let mut case_strings_by_section: BTreeMap<String, (Vec<String>, bool)> = BTreeMap::new();

    for ExampleDef {
        section,
        input,
        output,
        should_skip,
        number,
    } in cases.into_iter()
    {
        let (entries, has_unskipped_cases) =
            case_strings_by_section.entry(section.clone()).or_default();

        entries.push(format!(
            r#"{}#[test_case("{}", "{}"; "example_{}")]"#,
            if should_skip.is_some_and(|skip| skip) {
                "// "
            } else {
                ""
            },
            input.escape_default(),
            output.escape_default(),
            number
        ));

        if !should_skip.unwrap_or(false) {
            *has_unskipped_cases = true;
        }
    }

    for (section, (cases, has_unskipped)) in case_strings_by_section {
        if !has_unskipped {
            output_buffer.push_str("#[allow(unused)]\n");
        }

        for case in cases {
            output_buffer.push_str(&case);
            output_buffer.push('\n');
        }

        output_buffer.push_str(&format!(
            "fn {}(input: &str, output: &str) {{
    run_spec_test(input, output);
}}\n\n",
            section
        ));
    }

    std::fs::write(specs_file, output_buffer).expect("Failed to write the specs file");
}
